=============
signal
=============
.. module:: signal
    :synopsis: Receive notification of asynchronous system events

:Purpose: Receive notification of asynchronous system events
:Python Version: 1.4 and later

Description
===========

*Programming with Unix signal handlers is a non-trivial endeavor.  This is an introduction, and does not include all of the details you may need to use signals successfully on every platform.  There is some degree of standardization across versions of Unix, but there is also some variation, so consult documentation for your OS if you run into trouble.*

Signals are a means of notifying your program of an event, and having it handled asynchronously.  They can be generated by the system itself, or sent from one process to another.  Since signals interrupt the regular flow of your program, it is possible that some operations (especially I/O) may produce error if a signal is received in the middle.

Signals are identified by integers and are defined in the operating system C headers.  Python defines the signals appropriate for the platform as symbols in the <code>signal</code> module.  For the examples below, I will use SIGINT and SIGUSR1.  Both are typically defined for all Unix and Unix-like systems.

Receiving Signals
=================

As with other forms of event-based programming, signals are received by establishing a callback function, called a :term:`signal handler`, that is invoked when the signal occurs.  The arguments to your signal handler are the signal number and the stack frame from the point in your program that was interrupted by the signal.

::

    import signal
    import os
    import time

    def receive_signal(signum, stack):
        print 'Received:', signum

    signal.signal(signal.SIGUSR1, receive_signal)
    signal.signal(signal.SIGUSR2, receive_signal)

    print 'My PID is:', os.getpid()

    while True:
        print 'Waiting...'
        time.sleep(3)


This relatively simple example script loops indefinitely, pausing for a few seconds each time.  When a signal comes in, the sleep call is interrupted and the signal handler ``receive_signal()`` prints the signal number.  When the signal handler returns, the loop continues.  

To send signals to the running program, I use the command line program kill.  To produce the output below, I ran signal_signal.py in one window, then ``kill -USR1 $pid``, ``kill -USR2 $pid``, and ``kill -INT $pid`` in another.

::

    $ python signal_signal.py 
    My PID is: 71387
    Waiting...
    Waiting...
    Waiting...
    Received: 30
    Waiting...
    Waiting...
    Received: 31
    Waiting...
    Waiting...
    Traceback (most recent call last):
      File "signal_signal.py", line 25, in <module>
        time.sleep(3)
    KeyboardInterrupt


getsignal()
===========

To see what signal handlers are registered for a signal, use getsignal().  Pass the signal number as argument.  The return value is the registered handler, or one of the special values signal.SIG_IGN (if the signal is being ignored), signal.SIG_DFL (if the default behavior is being used), or None (if the existing signal handler was registered from C, rather than Python).

::

    import signal

    def alarm_received(n, stack):
        return

    signal.signal(signal.SIGALRM, alarm_received)

    signals_to_names = {}
    for n in dir(signal):
        if n.startswith('SIG') and not n.startswith('SIG_'):
            signals_to_names[getattr(signal, n)] = n

    for s in xrange(1, signal.NSIG):
        name = signals_to_names[s]
        handler = signal.getsignal(s)
        if handler is signal.SIG_DFL:
            handler = 'SIG_DFL'
        elif handler is signal.SIG_IGN:
            handler = 'SIG_IGN'
        print '%-10s (%2d):' % (name, s), handler


Again, since each OS may have different signals defined, the output you see from running this on other systems may vary.  This is from OS X:

::

    $ python signal_getsignal.py
    SIGHUP     ( 1): SIG_DFL
    SIGINT     ( 2): &lt;built-in function default_int_handler&gt;
    SIGQUIT    ( 3): SIG_DFL
    SIGILL     ( 4): SIG_DFL
    SIGTRAP    ( 5): SIG_DFL
    SIGIOT     ( 6): SIG_DFL
    SIGEMT     ( 7): SIG_DFL
    SIGFPE     ( 8): SIG_DFL
    SIGKILL    ( 9): None
    SIGBUS     (10): SIG_DFL
    SIGSEGV    (11): SIG_DFL
    SIGSYS     (12): SIG_DFL
    SIGPIPE    (13): SIG_IGN
    SIGALRM    (14): &lt;function alarm_received at 0x7c3f0&gt;
    SIGTERM    (15): SIG_DFL
    SIGURG     (16): SIG_DFL
    SIGSTOP    (17): None
    SIGTSTP    (18): SIG_DFL
    SIGCONT    (19): SIG_DFL
    SIGCHLD    (20): SIG_DFL
    SIGTTIN    (21): SIG_DFL
    SIGTTOU    (22): SIG_DFL
    SIGIO      (23): SIG_DFL
    SIGXCPU    (24): SIG_DFL
    SIGXFSZ    (25): SIG_IGN
    SIGVTALRM  (26): SIG_DFL
    SIGPROF    (27): SIG_DFL
    SIGWINCH   (28): SIG_DFL
    SIGINFO    (29): SIG_DFL
    SIGUSR1    (30): SIG_DFL
    SIGUSR2    (31): SIG_DFL


Sending Signals
===============

The function for sending signals is ``os.kill()``.  Its use is covered in the `PyMOTW article covering the os module :ref:`creating-processes-with-os-fork`.

Alarms
======

Alarms are a somewhat special sort of signal, where your program asks the OS to notify it after some period of time has elapsed.  As `the standard module documentation  for os http://docs.python.org/lib/node545.html`_ points out, this is useful for avoiding blocking indefinitely on an I/O operation or other system call.

::

    import signal
    import time

    def receive_alarm(signum, stack):
        print 'Alarm :', time.ctime()

    # Call receive_alarm in 2 seconds
    signal.signal(signal.SIGALRM, receive_alarm)
    signal.alarm(2)

    print 'Before:', time.ctime()
    time.sleep(4)
    print 'After :', time.ctime()


In this example, the call to ``sleep()`` does not last the full 4 seconds.

::

    $ python signal_alarm.py
    Before: Sun Aug 17 10:51:09 2008
    Alarm : Sun Aug 17 10:51:11 2008
    After : Sun Aug 17 10:51:11 2008


Ignoring Signals
================

To ignore a signal, register SIG_IGN as the handler.  This script replaces the default handler for SIGINT with SIG_IGN, and registers a handler for SIGUSR1.  Then it uses signal.pause() to wait for a signal to be received.

::

    import signal
    import os
    import time

    def do_exit(sig, stack):
        raise SystemExit('Exiting')

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGUSR1, do_exit)

    print 'My PID:', os.getpid()

    signal.pause()


Normally SIGINT (the signal sent by the shell to your program when you hit Ctrl-C) raises a KeyboardInterrupt.  In this case, we ignore SIGINT and raise SystemExit when we see SIGUSR1.  Each ``^C`` represents an attempt to use Ctrl-C to kill the script from the terminal.  Using ``kill -USR1 72531`` from another terminal eventually causes the script to exit.

::

    $ python signal_ignore.py 
    My PID: 72598
    ^C^C^C^CExiting


Signals and Threads
===================

Signals and threads don't generally mix well.  Only the main thread of a process will receive signals, so it is not generally useful to try to use them in threads.  The following example sets up a signal handler, waits for the signal in one thread, and sends the signal from another.

::

    import signal
    import threading
    import os
    import time

    def signal_handler(num, stack):
        print 'Received signal %d in %s' % (num, threading.currentThread())

    signal.signal(signal.SIGUSR1, signal_handler)

    def wait_for_signal():
        print 'Waiting for signal in', threading.currentThread()
        signal.pause()
        print 'Done waiting'

    # Start a thread that will not receive the signal
    receiver = threading.Thread(target=wait_for_signal, name='receiver')
    receiver.start()
    time.sleep(0.1)

    def send_signal():
        print 'Sending signal in', threading.currentThread()
        os.kill(os.getpid(), signal.SIGUSR1)

    sender = threading.Thread(target=send_signal, name='sender')
    sender.start()
    sender.join()

    # Wait for the thread to see the signal (not going to happen!)
    print 'Waiting for', receiver
    signal.alarm(2)
    receiver.join()


Notice that the signal handlers were all registered in the main thread.  This is a requirement of the signal module implementation for Python, regardless of underlying platform support for mixing threads and signals.  Although the receiver thread calls signal.pause(), it does not receive the signal.  The signal.alarm(2) call near the end of the example prevents an infinite block, since the receiver thread will never exit.

::

    $ python signal_threads.py 
    Waiting for signal in <Thread(receiver, started)>
    Sending signal in <Thread(sender, started)>
    Received signal 30 in <_MainThread(MainThread, started)>
    Waiting for <Thread(receiver, started)>
    Alarm clock


Although alarms can be set in threads, they are also received by the main thread.

::

    import signal
    import time
    import threading

    def signal_handler(num, stack):
        print time.ctime(), 'Alarm in', threading.currentThread()

    signal.signal(signal.SIGALRM, signal_handler)

    def use_alarm():
        print time.ctime(), 'Setting alarm in', threading.currentThread()
        signal.alarm(1)
        print time.ctime(), 'Sleeping in', threading.currentThread()
        time.sleep(3)
        print time.ctime(), 'Done with sleep'

    # Start a thread that will not receive the signal
    alarm_thread = threading.Thread(target=use_alarm, name='alarm_thread')
    alarm_thread.start()
    time.sleep(0.1)

    # Wait for the thread to see the signal (not going to happen!)
    print time.ctime(), 'Waiting for', alarm_thread
    alarm_thread.join()

    print time.ctime(), 'Exiting normally'


Notice that the alarm does not abort the sleep() call in use_alarm().

::

    $ python signal_threads_alarm.py
    Sun Aug 17 12:06:00 2008 Setting alarm in <Thread(alarm_thread, started)>
    Sun Aug 17 12:06:00 2008 Sleeping in <Thread(alarm_thread, started)>
    Sun Aug 17 12:06:00 2008 Waiting for <Thread(alarm_thread, started)>;
    Sun Aug 17 12:06:03 2008 Done with sleep
    Sun Aug 17 12:06:03 2008 Alarm in <_MainThread(MainThread, started)>
    Sun Aug 17 12:06:03 2008 Exiting normally

